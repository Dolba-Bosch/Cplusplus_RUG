Explanation of why each statement works
- cout << (value % 2 == 0 ? "even" : "odd") << '\n';
By definition a number is even when it is divisible by two. This is equivalent
to having a remainder of 0 when divided by 2. Hence we check if the remainder
is zero to determine if the number is even or odd.

- cout << (value & 1 ? "odd" : "even") << '\n';
In binary, a number is composed of powers of two. Since every power of two
except 2^1 is even and the sum of even numbers is even, it is sufficient
to check if only the last bit is equal to one or zero. Hence we use the bitwise
AND to check if the last bit is 1 or 0.


- cout << ((value+1) / 2 == value / 2 ? "even" : "odd") << '\n';
Since C++ truncates the result of integer division, dividing is always rounded
down. Hence, if we add one to an even number and divide by two, the result will
be the same as the original number divided by two. 
If the number is odd, adding one will make it even and dividing by two will
result in a number that is one less than the original number divided by two.

- cout << (short((value | 0xFFFE) ^ 0xFFFF) ? "even" : "odd") << '\n';
Using the bitwise OR operator, all bits except the last one are set to 1. 
This results in a binary number with all bits set to 1 except the last bit.
A bitwise XOR with 0xFFFF is equivalent to flipping all bits. And thus the 
all bits are set to 0 except the last bit. The last bit will be 1 if the number
is even and 0 if the number is odd. The short cast is used as only the last bit
is needed to determine if the number is even or odd.

- cout << (short(value<<15) < 0 ? "odd" : "even") << '\n';
By shifting the number 15 bits to the left, the last bit is moved to the 16th
position. If the number is even, the last bit will be 0 and the number will 
equal zero. If the number is odd, the last bit will be 1 and the number will
be negative. Casting the value as short is necessary as it ensures the first bit
in the 16 bit number is the last bit of the original number.

cout << (short(value*0x8000) < 0 ? "odd" : "even") << '\n';
Multiplying the number by 0x8000 is equivalent to shifting the number 15 bits
to the left. The last bit is moved to the 16th position. If the number is even,
the last bit will be 0 and the number will equal zero. If the number is odd,
the last bit will be 1 and the number will be negative. As before, casting the
value as short is necessary as it ensures the first bit in the 16 bit number is
the last bit of the original number.

